package de.qabel.core.storage;

import java.io.File;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.nio.file.Files;
import java.security.InvalidKeyException;
import java.util.Arrays;
import java.util.UUID;

import javax.crypto.spec.SecretKeySpec;

import org.bouncycastle.util.encoders.Hex;
import org.junit.After;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;

import de.qabel.core.config.StorageServer;
import de.qabel.core.config.StorageVolume;
import de.qabel.core.exceptions.QblNetworkInvalidResponseException;
import de.qabel.core.exceptions.QblStorageBlobSizeExeeded;
import de.qabel.core.exceptions.QblStorageInvalidBlobName;
import de.qabel.core.exceptions.QblStorageInvalidToken;

public class StorageTest {
	private static final String SERVER_URI = "http://localhost:8000/data";
	private static final String KEY_HEX = "feffe9928665731c6d6a8f9467308308feffe9928665731c6d6a8f9467308308";
	private StorageVolume volume;

	@Before
	public void createVolume() throws QblNetworkInvalidResponseException, IOException, URISyntaxException {
		StorageServer server = new StorageServer(new URI(SERVER_URI), "");
		this.volume = StorageAction.createStorageVolume(server);
	}

	@After
	public void deleteVolume()
			throws QblNetworkInvalidResponseException, IOException, QblStorageInvalidToken {
		StorageAction.deleteStorageVolume(this.volume);
		boolean exists = StorageAction.existsStorageVolume(this.volume);
		Assert.assertFalse(exists);
	}

	@Test
	public void probeValidVolume() throws QblNetworkInvalidResponseException, IOException {
		boolean exists = StorageAction.existsStorageVolume(this.volume);
		Assert.assertTrue(exists);
	}

	@Test
	public void probeInvalidVolume() throws QblNetworkInvalidResponseException, IOException, URISyntaxException {
		// use a random UUID which is hopefully and most likely unused and thus invalid
		StorageVolume unknownVolume = new StorageVolume(new StorageServer(new URI(SERVER_URI), ""),
				UUID.randomUUID().toString(), "invalid1", "invalid2");
		boolean exists = StorageAction.existsStorageVolume(unknownVolume);
		Assert.assertFalse(exists);
	}

	@Test
	public void blobUploadDownloadCheck()
			throws InvalidKeyException, IOException, QblStorageBlobSizeExeeded, QblStorageInvalidToken, QblStorageInvalidBlobName {
		final byte[] blobBytes = {42, 23};
		final String blobName = "foo";
		StorageBlob blob = new StorageBlob(blobBytes, blobName);
		// TODO: key should be generated by the key factory
		SecretKeySpec key = new SecretKeySpec(Hex.decode(KEY_HEX), "AES");
		StorageAction.uploadBlob(this.volume, blob, key);
		File blobFile = StorageAction.retrieveBlob(this.volume, blobName, key);
		try {
			byte[] receivedBytes = Files.readAllBytes(blobFile.toPath());
			// assert that sent bytes are present and unaltered
			Assert.assertArrayEquals(blobBytes, Arrays.copyOfRange(receivedBytes, 0, blobBytes.length));
			// check that the padding is unaltered
			int foundPaddingBytes = 0;
			for (int i = blobBytes.length; i < receivedBytes.length; i++) {
				if ( receivedBytes[i] == 0 ) {
					foundPaddingBytes++;
				}
			}
			Assert.assertEquals(receivedBytes.length - blobBytes.length, foundPaddingBytes);
		} finally {
			blobFile.delete();
		}
	}
}
